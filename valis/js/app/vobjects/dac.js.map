{"version":3,"sources":["../../../../../www/js/app/vobjects/dac.js"],"names":[],"mappings":";;;;;;;;;;;;AAAA,OAAO,CAAC,sBAAD,EAAyB,UAAzB,EAAqC,aAArC,CAAP,EACA,UAAC,OAAD,EAAU,IAAV,EAAgB,QAAhB,EAA6B;MACrB;;;;;;;;;;;;;kCAEQ;AAAE,eAAO,CAAP,CAAF;;;;mCACC;AAAE,eAAO,CAAP,CAAF;;;;+BAEJ,SAAS,QAAQ,SAAS;;AAEjC,aAAK,IAAM,CAAN,IAAW,MAAhB,EAAwB;AACtB,cAAI,KAAK,QAAQ,gBAAR,CAAyB,MAAzB,EAAiC;AACxC,qBADwC;WAA1C;;AAIA,cAAM,KAAK,OAAO,CAAP,CAAL,CALgB;AAMtB,cAAI,OAAO,IAAP,EAAa;AACf,kBAAM,IAAI,KAAJ,YAAmB,eAAnB,CAAN,CADe;WAAjB;;AAIA,cAAI,CAAC,KAAK,YAAL,CAAkB,EAAlB,CAAD,EAAwB;AAC1B,gBAAM,YAAU,QAAQ,+CAAR,CAAY,QAAZ,EAAV,CADoB;AAE1B,gBAAM,MAAM,UAAQ,GAAG,QAAH,GAAc,KAAd,CAAoB,CAApB,EAAuB,GAAvB,CAAR,GAAwC,EAAxC,CAFc;AAG1B,kBAAM,IAAI,KAAJ,YAAmB,8BAAyB,cAAS,GAArD,CAAN,CAH0B;WAA5B;;AAMA,cAAM,SAAS,QAAQ,gBAAR,CAAyB,CAAzB,CAAT,CAhBgB;;AAkBtB,cAAI,OAAO,MAAP,KAAkB,GAAG,MAAH,EAAW;AAC/B,kBAAM,IAAI,KAAJ,CAAU,6CAAV,CAAN,CAD+B;WAAjC;;AAIA,eAAK,IAAI,IAAI,CAAJ,EAAO,IAAI,GAAG,MAAH,EAAW,GAA/B,EAAoC;;;AAGlC,mBAAO,CAAP,KAAa,GAAG,CAAH,CAAb,CAHkC;WAApC;SAtBF;;;;WAPE;IAAY,QAAQ,OAAR,EADS;;AAuC3B,MAAI,YAAJ,GAAmB,QAAnB,CAvC2B;AAwC3B,MAAI,aAAJ,GAAoB,WAApB,CAxC2B;;AA0C3B,SAAO,GAAP,CA1C2B;CAA7B,CADA","file":"dac.js","sourcesContent":["define(['app/vobjects/vobject', 'app/util', 'app/console'],\n(vobject, util, vconsole) => {\n  class DAC extends vobject.VObject {\n    // strictly stereo, for now\n    numInputs() { return 2; }\n    numOutputs() { return 0; }\n\n    generate(context, inputs, outputs) {\n      /* copy additively into external output buffers */\n      for (const i in inputs) {\n        if (i >= context.extOutputBuffers.length) {\n          continue;\n        }\n\n        const ib = inputs[i];\n        if (ib === null) {\n          throw new Error(`input ${i} === null`);\n        }\n\n        if (!util.isAudioArray(ib)) {\n          const type = `${(typeof ib).toString()}`;\n          const str = ib ? `${ib.toString().slice(0, 100)}` : '';\n          throw new Error(`input ${i} received non-audio: ${type}, ${str}`);\n        }\n\n        const buffer = context.extOutputBuffers[i];\n\n        if (buffer.length !== ib.length) {\n          throw new Error('input buffer length !== channel data length');\n        }\n\n        for (let s = 0; s < ib.length; s++) {\n          // adds, so if there are multiple sources writing to the buffer\n          // the audio will be mixed together\n          buffer[s] += ib[s];\n        }\n      }\n    }\n  }\n\n  DAC.vobjectClass = 'output';\n  DAC.vobjectSymbol = '&#x1f50a;';\n\n  return DAC;\n});\n"]}